{"version":3,"sources":["../../../src/verification/hooks.ts"],"sourcesContent":["/**\n * Verification Hooks Module\n * \n * Comprehensive verification and validation system for claude-flow operations.\n * Provides pre-task verification, post-task validation, integration testing,\n * truth telemetry, and rollback capabilities.\n */\n\nimport { Logger } from '../core/logger.js';\nimport { agenticHookManager } from '../services/agentic-flow-hooks/index.js';\nimport type {\n  AgenticHookContext,\n  HookHandlerResult,\n  HookRegistration,\n  WorkflowHookPayload,\n  PerformanceHookPayload,\n  MemoryHookPayload,\n} from '../services/agentic-flow-hooks/types.js';\nimport { TruthDBAdapter, type TruthScoreDocument, type SnapshotDocument } from './truth-db-adapter.js';\n\nconst logger = new Logger({\n  level: 'info',\n  format: 'text',\n  destination: 'console'\n}, { prefix: 'VerificationHooks' });\n\n// ===== Types & Interfaces =====\n\nexport interface VerificationConfig {\n  preTask: {\n    enabled: boolean;\n    checkers: PreTaskChecker[];\n    failureStrategy: 'abort' | 'warn' | 'continue';\n  };\n  postTask: {\n    enabled: boolean;\n    validators: PostTaskValidator[];\n    accuracyThreshold: number;\n  };\n  integration: {\n    enabled: boolean;\n    testSuites: IntegrationTestSuite[];\n    parallel: boolean;\n  };\n  telemetry: {\n    enabled: boolean;\n    truthValidators: TruthValidator[];\n    reportingInterval: number;\n  };\n  rollback: {\n    enabled: boolean;\n    triggers: RollbackTrigger[];\n    snapshotStrategy: 'automatic' | 'manual' | 'selective';\n  };\n}\n\nexport interface PreTaskChecker {\n  id: string;\n  name: string;\n  description: string;\n  priority: number;\n  check: (context: VerificationContext) => Promise<VerificationResult>;\n}\n\nexport interface PostTaskValidator {\n  id: string;\n  name: string;\n  description: string;\n  priority: number;\n  validate: (context: VerificationContext, result: any) => Promise<ValidationResult>;\n}\n\nexport interface IntegrationTestSuite {\n  id: string;\n  name: string;\n  description: string;\n  tests: IntegrationTest[];\n  requirements: string[];\n}\n\nexport interface IntegrationTest {\n  id: string;\n  name: string;\n  description: string;\n  execute: (context: VerificationContext) => Promise<TestResult>;\n  cleanup?: (context: VerificationContext) => Promise<void>;\n}\n\nexport interface TruthValidator {\n  id: string;\n  name: string;\n  description: string;\n  validate: (data: any, expected: any) => Promise<TruthResult>;\n}\n\nexport interface RollbackTrigger {\n  id: string;\n  name: string;\n  description: string;\n  condition: (context: VerificationContext, error?: Error) => boolean;\n  action: RollbackAction;\n}\n\nexport interface VerificationContext {\n  taskId: string;\n  sessionId: string;\n  timestamp: number;\n  metadata: Record<string, any>;\n  state: VerificationState;\n  snapshots: StateSnapshot[];\n  metrics: VerificationMetrics;\n}\n\nexport interface VerificationState {\n  phase: 'pre-task' | 'execution' | 'post-task' | 'validation' | 'complete' | 'failed';\n  checksPassed: string[];\n  checksFailed: string[];\n  validationResults: ValidationResult[];\n  testResults: TestResult[];\n  truthResults: TruthResult[];\n  errors: VerificationError[];\n}\n\nexport interface StateSnapshot {\n  id: string;\n  timestamp: number;\n  phase: string;\n  state: any;\n  metadata: Record<string, any>;\n}\n\nexport interface VerificationMetrics {\n  totalChecks: number;\n  passedChecks: number;\n  failedChecks: number;\n  executionTime: number;\n  accuracyScore: number;\n  confidenceScore: number;\n}\n\nexport interface VerificationResult {\n  passed: boolean;\n  score: number;\n  message: string;\n  details?: any;\n  recommendations?: string[];\n}\n\nexport interface ValidationResult {\n  valid: boolean;\n  accuracy: number;\n  confidence: number;\n  message: string;\n  details?: any;\n  evidence?: any[];\n}\n\nexport interface TestResult {\n  passed: boolean;\n  duration: number;\n  message: string;\n  details?: any;\n  logs?: string[];\n}\n\nexport interface TruthResult {\n  truthful: boolean;\n  accuracy: number;\n  confidence: number;\n  discrepancies: string[];\n  evidence: any[];\n}\n\nexport interface VerificationError {\n  type: 'check' | 'validation' | 'test' | 'truth' | 'system';\n  phase: string;\n  message: string;\n  details?: any;\n  recoverable: boolean;\n}\n\nexport type RollbackAction = \n  | 'restore-snapshot' \n  | 'revert-changes' \n  | 'reset-state' \n  | 'abort-task'\n  | 'retry-with-fallback';\n\n// ===== Default Configuration =====\n\nexport const DEFAULT_VERIFICATION_CONFIG: VerificationConfig = {\n  preTask: {\n    enabled: true,\n    checkers: [],\n    failureStrategy: 'abort',\n  },\n  postTask: {\n    enabled: true,\n    validators: [],\n    accuracyThreshold: 0.8,\n  },\n  integration: {\n    enabled: true,\n    testSuites: [],\n    parallel: true,\n  },\n  telemetry: {\n    enabled: true,\n    truthValidators: [],\n    reportingInterval: 30000, // 30 seconds\n  },\n  rollback: {\n    enabled: true,\n    triggers: [],\n    snapshotStrategy: 'automatic',\n  },\n};\n\n// ===== Verification Hook Manager =====\n\nexport class VerificationHookManager {\n  private config: VerificationConfig;\n  private contexts: Map<string, VerificationContext> = new Map();  // In-memory cache\n  private snapshots: Map<string, StateSnapshot[]> = new Map();     // In-memory cache\n  private db: TruthDBAdapter;  // Persistent storage\n\n  constructor(config: Partial<VerificationConfig> = {}) {\n    this.config = { ...DEFAULT_VERIFICATION_CONFIG, ...config };\n    this.db = new TruthDBAdapter();\n    this.initializeDB();\n    this.registerHooks();\n    this.startTelemetryReporting();\n  }\n\n  /**\n   * Initialize the persistent storage adapter\n   */\n  private async initializeDB(): Promise<void> {\n    try {\n      await this.db.initialize();\n      logger.info('TruthDBAdapter initialized for persistent storage');\n    } catch (error) {\n      logger.warn('TruthDBAdapter initialization failed, using in-memory fallback:', error);\n    }\n  }\n\n  /**\n   * Register all verification hooks with the agentic hook manager\n   */\n  private registerHooks(): void {\n    // Pre-task verification hook\n    this.registerPreTaskHook();\n    \n    // Post-task validation hook\n    this.registerPostTaskHook();\n    \n    // Integration test hook\n    this.registerIntegrationTestHook();\n    \n    // Truth telemetry hook\n    this.registerTruthTelemetryHook();\n    \n    // Rollback trigger hook\n    this.registerRollbackTriggerHook();\n\n    logger.info('Verification hooks registered successfully');\n  }\n\n  // ===== 1. Pre-Task Verification Hook =====\n\n  private registerPreTaskHook(): void {\n    const preTaskHook: HookRegistration = {\n      id: 'verification-pre-task',\n      type: 'workflow-start',\n      priority: 100, // High priority to run early\n      handler: async (payload: WorkflowHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.preTask.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.createVerificationContext(payload, context);\n        \n        try {\n          await this.executePreTaskChecks(verificationContext);\n          \n          const state = verificationContext.state;\n          if (state.checksFailed.length > 0) {\n            const strategy = this.config.preTask.failureStrategy;\n            \n            if (strategy === 'abort') {\n              return {\n                continue: false,\n                metadata: {\n                  verificationFailed: true,\n                  failedChecks: state.checksFailed,\n                  error: 'Pre-task verification failed'\n                }\n              };\n            } else if (strategy === 'warn') {\n              logger.warn('Pre-task verification warnings:', state.checksFailed);\n            }\n          }\n\n          // Create initial snapshot\n          await this.createSnapshot(verificationContext, 'pre-task-complete');\n\n          return {\n            continue: true,\n            modified: true,\n            payload: {\n              ...payload,\n              verificationContext: verificationContext.taskId\n            },\n            metadata: {\n              verificationPassed: true,\n              checksExecuted: state.checksPassed.length,\n              warnings: state.checksFailed.length\n            }\n          };\n        } catch (error) {\n          logger.error('Pre-task verification error:', error);\n          \n          return {\n            continue: this.config.preTask.failureStrategy !== 'abort',\n            metadata: {\n              verificationError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 30000, // 30 second timeout\n        async: false,\n      }\n    };\n\n    agenticHookManager.register(preTaskHook);\n  }\n\n  private async executePreTaskChecks(context: VerificationContext): Promise<void> {\n    const checkers = this.config.preTask.checkers.sort((a, b) => b.priority - a.priority);\n    \n    for (const checker of checkers) {\n      try {\n        const result = await checker.check(context);\n        \n        if (result.passed) {\n          context.state.checksPassed.push(checker.id);\n        } else {\n          context.state.checksFailed.push(checker.id);\n          context.state.errors.push({\n            type: 'check',\n            phase: 'pre-task',\n            message: result.message,\n            details: result.details,\n            recoverable: true\n          });\n        }\n\n        // Update metrics\n        context.metrics.totalChecks++;\n        if (result.passed) {\n          context.metrics.passedChecks++;\n        } else {\n          context.metrics.failedChecks++;\n        }\n      } catch (error) {\n        logger.error(`Pre-task checker '${checker.id}' failed:`, error);\n        context.state.checksFailed.push(checker.id);\n        context.state.errors.push({\n          type: 'check',\n          phase: 'pre-task',\n          message: `Checker '${checker.id}' threw an error: ${(error as Error).message}`,\n          details: error,\n          recoverable: false\n        });\n      }\n    }\n  }\n\n  // ===== 2. Post-Task Validation Hook =====\n\n  private registerPostTaskHook(): void {\n    const postTaskHook: HookRegistration = {\n      id: 'verification-post-task',\n      type: 'workflow-complete',\n      priority: 90,\n      handler: async (payload: WorkflowHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.postTask.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.getVerificationContext(payload.workflowId) || \n                                   this.createVerificationContext(payload, context);\n        \n        try {\n          await this.executePostTaskValidation(verificationContext, payload);\n          \n          const accuracy = this.calculateAccuracy(verificationContext);\n          const meetsThreshold = accuracy >= this.config.postTask.accuracyThreshold;\n\n          // Create completion snapshot\n          await this.createSnapshot(verificationContext, 'post-task-complete');\n\n          return {\n            continue: true,\n            modified: true,\n            payload: {\n              ...payload,\n              validationResults: verificationContext.state.validationResults,\n              accuracy,\n              meetsThreshold\n            },\n            metadata: {\n              validationComplete: true,\n              accuracy,\n              meetsThreshold,\n              validationCount: verificationContext.state.validationResults.length\n            },\n            sideEffects: [{\n              type: 'metric',\n              action: 'update',\n              data: {\n                name: 'verification.accuracy',\n                value: accuracy\n              }\n            }]\n          };\n        } catch (error) {\n          logger.error('Post-task validation error:', error);\n          \n          return {\n            continue: true,\n            metadata: {\n              validationError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 60000, // 60 second timeout\n        async: true,\n      }\n    };\n\n    agenticHookManager.register(postTaskHook);\n  }\n\n  private async executePostTaskValidation(\n    context: VerificationContext, \n    payload: WorkflowHookPayload\n  ): Promise<void> {\n    const validators = this.config.postTask.validators.sort((a, b) => b.priority - a.priority);\n    \n    for (const validator of validators) {\n      try {\n        const result = await validator.validate(context, payload.state);\n        context.state.validationResults.push(result);\n        \n        // Update metrics\n        if (result.valid) {\n          context.metrics.accuracyScore += result.accuracy;\n          context.metrics.confidenceScore += result.confidence;\n        }\n      } catch (error) {\n        logger.error(`Post-task validator '${validator.id}' failed:`, error);\n        context.state.errors.push({\n          type: 'validation',\n          phase: 'post-task',\n          message: `Validator '${validator.id}' threw an error: ${(error as Error).message}`,\n          details: error,\n          recoverable: false\n        });\n      }\n    }\n  }\n\n  // ===== 3. Integration Test Hook =====\n\n  private registerIntegrationTestHook(): void {\n    const integrationTestHook: HookRegistration = {\n      id: 'verification-integration-test',\n      type: 'workflow-step',\n      priority: 80,\n      filter: {\n        patterns: [/integration.*test/i, /test.*integration/i]\n      },\n      handler: async (payload: WorkflowHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.integration.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.getVerificationContext(payload.workflowId) || \n                                   this.createVerificationContext(payload, context);\n        \n        try {\n          await this.executeIntegrationTests(verificationContext);\n          \n          const allTestsPassed = verificationContext.state.testResults.every(r => r.passed);\n          const testCount = verificationContext.state.testResults.length;\n          const passedCount = verificationContext.state.testResults.filter(r => r.passed).length;\n\n          return {\n            continue: true,\n            modified: true,\n            payload: {\n              ...payload,\n              testResults: verificationContext.state.testResults,\n              allTestsPassed,\n              testSummary: {\n                total: testCount,\n                passed: passedCount,\n                failed: testCount - passedCount\n              }\n            },\n            metadata: {\n              integrationTestsComplete: true,\n              allTestsPassed,\n              testCount,\n              passedCount\n            },\n            sideEffects: [{\n              type: 'metric',\n              action: 'update',\n              data: {\n                name: 'verification.integration.success_rate',\n                value: passedCount / testCount\n              }\n            }]\n          };\n        } catch (error) {\n          logger.error('Integration test execution error:', error);\n          \n          return {\n            continue: true,\n            metadata: {\n              integrationTestError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 120000, // 2 minute timeout for tests\n        async: true,\n      }\n    };\n\n    agenticHookManager.register(integrationTestHook);\n  }\n\n  private async executeIntegrationTests(context: VerificationContext): Promise<void> {\n    const testSuites = this.config.integration.testSuites;\n    \n    for (const suite of testSuites) {\n      // Check if requirements are met\n      const requirementsMet = await this.checkTestRequirements(suite.requirements, context);\n      if (!requirementsMet) {\n        logger.warn(`Skipping test suite '${suite.id}' - requirements not met`);\n        continue;\n      }\n\n      if (this.config.integration.parallel) {\n        // Execute tests in parallel\n        const testPromises = suite.tests.map(test => this.executeIntegrationTest(test, context));\n        const results = await Promise.allSettled(testPromises);\n        \n        results.forEach((result, index) => {\n          if (result.status === 'fulfilled') {\n            context.state.testResults.push(result.value);\n          } else {\n            context.state.testResults.push({\n              passed: false,\n              duration: 0,\n              message: `Test '${suite.tests[index].id}' failed: ${result.reason}`,\n              details: result.reason\n            });\n          }\n        });\n      } else {\n        // Execute tests sequentially\n        for (const test of suite.tests) {\n          try {\n            const result = await this.executeIntegrationTest(test, context);\n            context.state.testResults.push(result);\n          } catch (error) {\n            context.state.testResults.push({\n              passed: false,\n              duration: 0,\n              message: `Test '${test.id}' failed: ${(error as Error).message}`,\n              details: error\n            });\n          }\n        }\n      }\n    }\n  }\n\n  private async executeIntegrationTest(\n    test: IntegrationTest, \n    context: VerificationContext\n  ): Promise<TestResult> {\n    const startTime = Date.now();\n    \n    try {\n      const result = await test.execute(context);\n      result.duration = Date.now() - startTime;\n      \n      // Cleanup if provided\n      if (test.cleanup) {\n        try {\n          await test.cleanup(context);\n        } catch (cleanupError) {\n          logger.warn(`Test cleanup failed for '${test.id}':`, cleanupError);\n        }\n      }\n      \n      return result;\n    } catch (error) {\n      return {\n        passed: false,\n        duration: Date.now() - startTime,\n        message: `Test execution failed: ${(error as Error).message}`,\n        details: error\n      };\n    }\n  }\n\n  private async checkTestRequirements(\n    requirements: string[], \n    context: VerificationContext\n  ): Promise<boolean> {\n    // Simple requirement checking - can be extended\n    for (const requirement of requirements) {\n      if (requirement.startsWith('env:')) {\n        const envVar = requirement.substring(4);\n        if (!process.env[envVar]) {\n          return false;\n        }\n      } else if (requirement.startsWith('check:')) {\n        const checkId = requirement.substring(6);\n        if (!context.state.checksPassed.includes(checkId)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // ===== 4. Truth Telemetry Hook =====\n\n  private registerTruthTelemetryHook(): void {\n    const truthTelemetryHook: HookRegistration = {\n      id: 'verification-truth-telemetry',\n      type: 'performance-metric',\n      priority: 70,\n      handler: async (payload: PerformanceHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.telemetry.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.getOrCreateVerificationContext(payload, context);\n        \n        try {\n          await this.executeTruthValidation(verificationContext, payload);\n          \n          const truthfulness = this.calculateTruthfulness(verificationContext);\n          \n          return {\n            continue: true,\n            modified: true,\n            payload: {\n              ...payload,\n              truthResults: verificationContext.state.truthResults,\n              truthfulness\n            },\n            metadata: {\n              truthValidationComplete: true,\n              truthfulness,\n              validatorCount: this.config.telemetry.truthValidators.length\n            },\n            sideEffects: [\n              {\n                type: 'metric',\n                action: 'update',\n                data: {\n                  name: 'verification.truthfulness',\n                  value: truthfulness\n                }\n              },\n              {\n                type: 'memory',\n                action: 'store',\n                data: {\n                  key: `truth_telemetry_${Date.now()}`,\n                  value: {\n                    timestamp: Date.now(),\n                    truthfulness,\n                    results: verificationContext.state.truthResults\n                  }\n                }\n              }\n            ]\n          };\n        } catch (error) {\n          logger.error('Truth telemetry execution error:', error);\n          \n          return {\n            continue: true,\n            metadata: {\n              truthTelemetryError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 45000, // 45 second timeout\n        async: true,\n      }\n    };\n\n    agenticHookManager.register(truthTelemetryHook);\n  }\n\n  private async executeTruthValidation(\n    context: VerificationContext, \n    payload: PerformanceHookPayload\n  ): Promise<void> {\n    const validators = this.config.telemetry.truthValidators;\n    \n    for (const validator of validators) {\n      try {\n        // Extract data and expected values from payload\n        const data = payload.context.metrics || payload.value;\n        const expected = payload.threshold; // Use threshold as expected value\n        \n        const result = await validator.validate(data, expected);\n        context.state.truthResults.push(result);\n      } catch (error) {\n        logger.error(`Truth validator '${validator.id}' failed:`, error);\n        context.state.errors.push({\n          type: 'truth',\n          phase: 'telemetry',\n          message: `Truth validator '${validator.id}' threw an error: ${(error as Error).message}`,\n          details: error,\n          recoverable: false\n        });\n      }\n    }\n  }\n\n  private calculateTruthfulness(context: VerificationContext): number {\n    const truthResults = context.state.truthResults;\n    if (truthResults.length === 0) return 1.0;\n    \n    const totalAccuracy = truthResults.reduce((sum, result) => sum + result.accuracy, 0);\n    return totalAccuracy / truthResults.length;\n  }\n\n  // ===== 5. Rollback Trigger Hook =====\n\n  private registerRollbackTriggerHook(): void {\n    const rollbackTriggerHook: HookRegistration = {\n      id: 'verification-rollback-trigger',\n      type: 'workflow-error',\n      priority: 95, // Very high priority for error handling\n      handler: async (payload: WorkflowHookPayload, context: AgenticHookContext): Promise<HookHandlerResult> => {\n        if (!this.config.rollback.enabled) {\n          return { continue: true };\n        }\n\n        const verificationContext = this.getVerificationContext(payload.workflowId);\n        if (!verificationContext) {\n          logger.warn('No verification context found for rollback evaluation');\n          return { continue: true };\n        }\n\n        try {\n          const shouldRollback = await this.evaluateRollbackTriggers(verificationContext, payload.error);\n          \n          if (shouldRollback) {\n            const rollbackResult = await this.executeRollback(verificationContext);\n            \n            return {\n              continue: rollbackResult.success,\n              modified: true,\n              payload: {\n                ...payload,\n                rollbackExecuted: true,\n                rollbackResult\n              },\n              metadata: {\n                rollbackTriggered: true,\n                rollbackSuccess: rollbackResult.success,\n                rollbackAction: rollbackResult.action\n              },\n              sideEffects: [\n                {\n                  type: 'log',\n                  action: 'warn',\n                  data: {\n                    level: 'warn',\n                    message: 'Rollback triggered due to verification failure',\n                    data: rollbackResult\n                  }\n                },\n                {\n                  type: 'metric',\n                  action: 'increment',\n                  data: {\n                    name: 'verification.rollbacks.triggered'\n                  }\n                }\n              ]\n            };\n          }\n\n          return { continue: true };\n        } catch (error) {\n          logger.error('Rollback trigger evaluation error:', error);\n          \n          return {\n            continue: true,\n            metadata: {\n              rollbackError: true,\n              error: (error as Error).message\n            }\n          };\n        }\n      },\n      options: {\n        timeout: 30000, // 30 second timeout\n        async: false, // Critical for error handling\n      }\n    };\n\n    agenticHookManager.register(rollbackTriggerHook);\n  }\n\n  private async evaluateRollbackTriggers(\n    context: VerificationContext, \n    error?: Error\n  ): Promise<boolean> {\n    const triggers = this.config.rollback.triggers;\n    \n    for (const trigger of triggers) {\n      try {\n        if (trigger.condition(context, error)) {\n          logger.info(`Rollback trigger '${trigger.id}' activated`);\n          return true;\n        }\n      } catch (triggerError) {\n        logger.error(`Rollback trigger '${trigger.id}' evaluation failed:`, triggerError);\n      }\n    }\n    \n    return false;\n  }\n\n  private async executeRollback(context: VerificationContext): Promise<{\n    success: boolean;\n    action: string;\n    details?: any;\n  }> {\n    try {\n      const snapshots = this.snapshots.get(context.taskId) || [];\n      const latestSnapshot = snapshots[snapshots.length - 1];\n      \n      if (!latestSnapshot) {\n        throw new Error('No snapshots available for rollback');\n      }\n\n      // Execute rollback based on strategy\n      switch (this.config.rollback.snapshotStrategy) {\n        case 'automatic':\n          await this.restoreSnapshot(context, latestSnapshot);\n          break;\n          \n        case 'selective':\n          // Find the best snapshot to restore to\n          const bestSnapshot = this.findBestRollbackSnapshot(snapshots);\n          await this.restoreSnapshot(context, bestSnapshot);\n          break;\n          \n        default:\n          await this.restoreSnapshot(context, latestSnapshot);\n      }\n\n      return {\n        success: true,\n        action: 'snapshot-restored',\n        details: {\n          snapshotId: latestSnapshot.id,\n          timestamp: latestSnapshot.timestamp\n        }\n      };\n    } catch (error) {\n      logger.error('Rollback execution failed:', error);\n      \n      return {\n        success: false,\n        action: 'rollback-failed',\n        details: (error as Error).message\n      };\n    }\n  }\n\n  // ===== Helper Methods =====\n\n  private createVerificationContext(\n    payload: WorkflowHookPayload,\n    context: AgenticHookContext\n  ): VerificationContext {\n    const verificationContext: VerificationContext = {\n      taskId: payload.workflowId,\n      sessionId: context.sessionId,\n      timestamp: Date.now(),\n      metadata: { ...payload.state, ...context.metadata },\n      state: {\n        phase: 'pre-task',\n        checksPassed: [],\n        checksFailed: [],\n        validationResults: [],\n        testResults: [],\n        truthResults: [],\n        errors: []\n      },\n      snapshots: [],\n      metrics: {\n        totalChecks: 0,\n        passedChecks: 0,\n        failedChecks: 0,\n        executionTime: 0,\n        accuracyScore: 0,\n        confidenceScore: 0\n      }\n    };\n\n    // Save to in-memory cache (fast access)\n    this.contexts.set(verificationContext.taskId, verificationContext);\n\n    // Persist to AgentDB (async, fire-and-forget to not block)\n    this.persistContext(verificationContext).catch(err =>\n      logger.warn(`Failed to persist context ${verificationContext.taskId}:`, err)\n    );\n\n    return verificationContext;\n  }\n\n  /**\n   * Persist verification context to AgentDB\n   */\n  private async persistContext(context: VerificationContext): Promise<void> {\n    const doc: TruthScoreDocument = {\n      taskId: context.taskId,\n      sessionId: context.sessionId,\n      timestamp: context.timestamp,\n      phase: context.state.phase,\n      accuracyScore: context.metrics.accuracyScore,\n      confidenceScore: context.metrics.confidenceScore,\n      passed: context.state.checksFailed.length === 0,\n      checksPassed: context.state.checksPassed,\n      checksFailed: context.state.checksFailed,\n      errorCount: context.state.errors.length,\n      metadata: context.metadata\n    };\n    await this.db.saveContext(context.taskId, doc);\n  }\n\n  private getVerificationContext(taskId: string): VerificationContext | undefined {\n    return this.contexts.get(taskId);\n  }\n\n  private getOrCreateVerificationContext(\n    payload: any, \n    context: AgenticHookContext\n  ): VerificationContext {\n    const taskId = payload.workflowId || payload.context?.taskId || context.correlationId;\n    \n    let verificationContext = this.contexts.get(taskId);\n    if (!verificationContext) {\n      verificationContext = this.createVerificationContext(\n        { workflowId: taskId, state: payload.context || {} } as WorkflowHookPayload,\n        context\n      );\n    }\n    \n    return verificationContext;\n  }\n\n  private async createSnapshot(\n    context: VerificationContext,\n    phase: string\n  ): Promise<void> {\n    const snapshot: StateSnapshot = {\n      id: `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: Date.now(),\n      phase,\n      state: JSON.parse(JSON.stringify(context.state)),\n      metadata: JSON.parse(JSON.stringify(context.metadata))\n    };\n\n    // Save to in-memory cache\n    if (!this.snapshots.has(context.taskId)) {\n      this.snapshots.set(context.taskId, []);\n    }\n    this.snapshots.get(context.taskId)!.push(snapshot);\n    context.snapshots.push(snapshot);\n\n    // Persist snapshot to AgentDB\n    const snapshotDoc: SnapshotDocument = {\n      snapshotId: snapshot.id,\n      taskId: context.taskId,\n      timestamp: snapshot.timestamp,\n      phase: snapshot.phase,\n      state: snapshot.state,\n      metadata: snapshot.metadata\n    };\n    this.db.saveSnapshot(context.taskId, snapshotDoc).catch(err =>\n      logger.warn(`Failed to persist snapshot ${snapshot.id}:`, err)\n    );\n\n    logger.debug(`Created snapshot '${snapshot.id}' for task '${context.taskId}' in phase '${phase}'`);\n  }\n\n  private async restoreSnapshot(\n    context: VerificationContext, \n    snapshot: StateSnapshot\n  ): Promise<void> {\n    context.state = JSON.parse(JSON.stringify(snapshot.state));\n    context.metadata = JSON.parse(JSON.stringify(snapshot.metadata));\n    \n    logger.info(`Restored snapshot '${snapshot.id}' for task '${context.taskId}'`);\n  }\n\n  private findBestRollbackSnapshot(snapshots: StateSnapshot[]): StateSnapshot {\n    // Find the latest snapshot with successful state\n    const successfulSnapshots = snapshots.filter(s => \n      s.phase.includes('complete') && !s.phase.includes('error')\n    );\n    \n    return successfulSnapshots.length > 0 \n      ? successfulSnapshots[successfulSnapshots.length - 1]\n      : snapshots[snapshots.length - 1];\n  }\n\n  private calculateAccuracy(context: VerificationContext): number {\n    const validationResults = context.state.validationResults;\n    if (validationResults.length === 0) return 1.0;\n    \n    const totalAccuracy = validationResults.reduce((sum, result) => sum + result.accuracy, 0);\n    return totalAccuracy / validationResults.length;\n  }\n\n  private startTelemetryReporting(): void {\n    if (!this.config.telemetry.enabled) return;\n\n    setInterval(() => {\n      this.generateTelemetryReport();\n    }, this.config.telemetry.reportingInterval);\n  }\n\n  private generateTelemetryReport(): void {\n    const report = {\n      timestamp: Date.now(),\n      activeContexts: this.contexts.size,\n      totalSnapshots: Array.from(this.snapshots.values()).reduce((sum, arr) => sum + arr.length, 0),\n      metrics: this.aggregateMetrics()\n    };\n\n    logger.info('Verification telemetry report:', report);\n    \n    // Emit telemetry event for external systems\n    agenticHookManager.emit('verification:telemetry', report);\n  }\n\n  private aggregateMetrics(): any {\n    const allContexts = Array.from(this.contexts.values());\n    \n    return {\n      totalChecks: allContexts.reduce((sum, ctx) => sum + ctx.metrics.totalChecks, 0),\n      totalPassed: allContexts.reduce((sum, ctx) => sum + ctx.metrics.passedChecks, 0),\n      totalFailed: allContexts.reduce((sum, ctx) => sum + ctx.metrics.failedChecks, 0),\n      averageAccuracy: allContexts.length > 0 \n        ? allContexts.reduce((sum, ctx) => sum + ctx.metrics.accuracyScore, 0) / allContexts.length\n        : 0,\n      averageConfidence: allContexts.length > 0\n        ? allContexts.reduce((sum, ctx) => sum + ctx.metrics.confidenceScore, 0) / allContexts.length\n        : 0\n    };\n  }\n\n  // ===== Public API =====\n\n  /**\n   * Add a pre-task checker\n   */\n  public addPreTaskChecker(checker: PreTaskChecker): void {\n    this.config.preTask.checkers.push(checker);\n    logger.info(`Added pre-task checker: ${checker.name}`);\n  }\n\n  /**\n   * Add a post-task validator\n   */\n  public addPostTaskValidator(validator: PostTaskValidator): void {\n    this.config.postTask.validators.push(validator);\n    logger.info(`Added post-task validator: ${validator.name}`);\n  }\n\n  /**\n   * Add an integration test suite\n   */\n  public addIntegrationTestSuite(testSuite: IntegrationTestSuite): void {\n    this.config.integration.testSuites.push(testSuite);\n    logger.info(`Added integration test suite: ${testSuite.name}`);\n  }\n\n  /**\n   * Add a truth validator\n   */\n  public addTruthValidator(validator: TruthValidator): void {\n    this.config.telemetry.truthValidators.push(validator);\n    logger.info(`Added truth validator: ${validator.name}`);\n  }\n\n  /**\n   * Add a rollback trigger\n   */\n  public addRollbackTrigger(trigger: RollbackTrigger): void {\n    this.config.rollback.triggers.push(trigger);\n    logger.info(`Added rollback trigger: ${trigger.name}`);\n  }\n\n  /**\n   * Get verification status for a task\n   */\n  public getVerificationStatus(taskId: string): VerificationContext | undefined {\n    return this.contexts.get(taskId);\n  }\n\n  /**\n   * Get verification metrics\n   */\n  public getMetrics(): any {\n    return this.aggregateMetrics();\n  }\n\n  /**\n   * Get persistent storage statistics\n   */\n  public async getStorageStats(): Promise<{\n    initialized: boolean;\n    vectorCount?: number;\n    dbPath?: string;\n    error?: string;\n  }> {\n    return this.db.getStats();\n  }\n\n  /**\n   * Check if persistent storage is available\n   */\n  public isStorageReady(): boolean {\n    return this.db.isReady();\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(newConfig: Partial<VerificationConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    logger.info('Verification configuration updated');\n  }\n\n  /**\n   * Cleanup old contexts and snapshots\n   */\n  public cleanup(maxAge: number = 24 * 60 * 60 * 1000): void {\n    const cutoff = Date.now() - maxAge;\n    \n    // Cleanup contexts\n    for (const [taskId, context] of this.contexts.entries()) {\n      if (context.timestamp < cutoff) {\n        this.contexts.delete(taskId);\n        this.snapshots.delete(taskId);\n      }\n    }\n    \n    logger.info(`Cleaned up verification data older than ${maxAge}ms`);\n  }\n}\n\n// ===== Default Verification Components =====\n\nexport const DEFAULT_PRE_TASK_CHECKERS: PreTaskChecker[] = [\n  {\n    id: 'environment-check',\n    name: 'Environment Validation',\n    description: 'Validates that required environment variables and dependencies are available',\n    priority: 100,\n    check: async (context: VerificationContext): Promise<VerificationResult> => {\n      // Basic environment validation\n      const requiredEnvVars = ['NODE_ENV'];\n      const missing = requiredEnvVars.filter(envVar => !process.env[envVar]);\n      \n      return {\n        passed: missing.length === 0,\n        score: missing.length === 0 ? 1.0 : 0.5,\n        message: missing.length === 0 \n          ? 'Environment validation passed' \n          : `Missing environment variables: ${missing.join(', ')}`,\n        details: { missing, available: requiredEnvVars.filter(envVar => process.env[envVar]) },\n        recommendations: missing.length > 0 \n          ? [`Set missing environment variables: ${missing.join(', ')}`]\n          : undefined\n      };\n    }\n  },\n  {\n    id: 'resource-check',\n    name: 'Resource Availability',\n    description: 'Checks system resources and capacity',\n    priority: 90,\n    check: async (context: VerificationContext): Promise<VerificationResult> => {\n      // Simple memory check\n      const memUsage = process.memoryUsage();\n      const heapUsedMB = memUsage.heapUsed / 1024 / 1024;\n      const heapTotalMB = memUsage.heapTotal / 1024 / 1024;\n      const usageRatio = heapUsedMB / heapTotalMB;\n      \n      return {\n        passed: usageRatio < 0.9, // Less than 90% memory usage\n        score: Math.max(0, 1 - usageRatio),\n        message: `Memory usage: ${heapUsedMB.toFixed(2)}MB / ${heapTotalMB.toFixed(2)}MB (${(usageRatio * 100).toFixed(1)}%)`,\n        details: { memUsage, usageRatio },\n        recommendations: usageRatio > 0.8 \n          ? ['Consider freeing memory before proceeding']\n          : undefined\n      };\n    }\n  }\n];\n\nexport const DEFAULT_POST_TASK_VALIDATORS: PostTaskValidator[] = [\n  {\n    id: 'completion-validator',\n    name: 'Task Completion Validation',\n    description: 'Validates that the task completed successfully',\n    priority: 100,\n    validate: async (context: VerificationContext, result: any): Promise<ValidationResult> => {\n      const hasErrors = context.state.errors.length > 0;\n      const hasFailedChecks = context.state.checksFailed.length > 0;\n      \n      return {\n        valid: !hasErrors && !hasFailedChecks,\n        accuracy: hasErrors || hasFailedChecks ? 0.5 : 1.0,\n        confidence: 0.9,\n        message: hasErrors || hasFailedChecks \n          ? 'Task completed with errors or failed checks'\n          : 'Task completed successfully',\n        details: {\n          errorCount: context.state.errors.length,\n          failedCheckCount: context.state.checksFailed.length\n        }\n      };\n    }\n  }\n];\n\nexport const DEFAULT_TRUTH_VALIDATORS: TruthValidator[] = [\n  {\n    id: 'data-consistency-validator',\n    name: 'Data Consistency Validation',\n    description: 'Validates data consistency and integrity',\n    validate: async (data: any, expected: any): Promise<TruthResult> => {\n      // Simple JSON comparison for data consistency\n      const dataStr = JSON.stringify(data);\n      const expectedStr = JSON.stringify(expected);\n      const isEqual = dataStr === expectedStr;\n      \n      return {\n        truthful: isEqual,\n        accuracy: isEqual ? 1.0 : 0.0,\n        confidence: 0.95,\n        discrepancies: isEqual ? [] : ['Data does not match expected structure'],\n        evidence: [{ data, expected, match: isEqual }]\n      };\n    }\n  }\n];\n\nexport const DEFAULT_ROLLBACK_TRIGGERS: RollbackTrigger[] = [\n  {\n    id: 'error-threshold-trigger',\n    name: 'Error Threshold Trigger',\n    description: 'Triggers rollback when error count exceeds threshold',\n    condition: (context: VerificationContext, error?: Error): boolean => {\n      return context.state.errors.filter(e => !e.recoverable).length > 3;\n    },\n    action: 'restore-snapshot'\n  },\n  {\n    id: 'accuracy-threshold-trigger',\n    name: 'Accuracy Threshold Trigger',\n    description: 'Triggers rollback when accuracy falls below threshold',\n    condition: (context: VerificationContext, error?: Error): boolean => {\n      return context.metrics.accuracyScore < 0.5 && context.state.validationResults.length > 0;\n    },\n    action: 'restore-snapshot'\n  }\n];\n\n// ===== Export Singleton Instance =====\n\nexport const verificationHookManager = new VerificationHookManager({\n  preTask: {\n    enabled: true,\n    checkers: DEFAULT_PRE_TASK_CHECKERS,\n    failureStrategy: 'abort'\n  },\n  postTask: {\n    enabled: true,\n    validators: DEFAULT_POST_TASK_VALIDATORS,\n    accuracyThreshold: 0.8\n  },\n  integration: {\n    enabled: true,\n    testSuites: [],\n    parallel: true\n  },\n  telemetry: {\n    enabled: true,\n    truthValidators: DEFAULT_TRUTH_VALIDATORS,\n    reportingInterval: 30000\n  },\n  rollback: {\n    enabled: true,\n    triggers: DEFAULT_ROLLBACK_TRIGGERS,\n    snapshotStrategy: 'automatic'\n  }\n});\n\n// Initialize default components\nlogger.info('Verification hooks module initialized with default configuration');"],"names":["Logger","agenticHookManager","TruthDBAdapter","logger","level","format","destination","prefix","DEFAULT_VERIFICATION_CONFIG","preTask","enabled","checkers","failureStrategy","postTask","validators","accuracyThreshold","integration","testSuites","parallel","telemetry","truthValidators","reportingInterval","rollback","triggers","snapshotStrategy","VerificationHookManager","config","contexts","Map","snapshots","db","initializeDB","registerHooks","startTelemetryReporting","initialize","info","error","warn","registerPreTaskHook","registerPostTaskHook","registerIntegrationTestHook","registerTruthTelemetryHook","registerRollbackTriggerHook","preTaskHook","id","type","priority","handler","payload","context","continue","verificationContext","createVerificationContext","executePreTaskChecks","state","checksFailed","length","strategy","metadata","verificationFailed","failedChecks","createSnapshot","modified","taskId","verificationPassed","checksExecuted","checksPassed","warnings","verificationError","message","options","timeout","async","register","sort","a","b","checker","result","check","passed","push","errors","phase","details","recoverable","metrics","totalChecks","passedChecks","postTaskHook","getVerificationContext","workflowId","executePostTaskValidation","accuracy","calculateAccuracy","meetsThreshold","validationResults","validationComplete","validationCount","sideEffects","action","data","name","value","validationError","validator","validate","valid","accuracyScore","confidenceScore","confidence","integrationTestHook","filter","patterns","executeIntegrationTests","allTestsPassed","testResults","every","r","testCount","passedCount","testSummary","total","failed","integrationTestsComplete","integrationTestError","suite","requirementsMet","checkTestRequirements","requirements","testPromises","tests","map","test","executeIntegrationTest","results","Promise","allSettled","forEach","index","status","duration","reason","startTime","Date","now","execute","cleanup","cleanupError","requirement","startsWith","envVar","substring","process","env","checkId","includes","truthTelemetryHook","getOrCreateVerificationContext","executeTruthValidation","truthfulness","calculateTruthfulness","truthResults","truthValidationComplete","validatorCount","key","timestamp","truthTelemetryError","expected","threshold","totalAccuracy","reduce","sum","rollbackTriggerHook","shouldRollback","evaluateRollbackTriggers","rollbackResult","executeRollback","success","rollbackExecuted","rollbackTriggered","rollbackSuccess","rollbackAction","rollbackError","trigger","condition","triggerError","get","latestSnapshot","Error","restoreSnapshot","bestSnapshot","findBestRollbackSnapshot","snapshotId","sessionId","executionTime","set","persistContext","catch","err","doc","errorCount","saveContext","correlationId","snapshot","Math","random","toString","substr","JSON","parse","stringify","has","snapshotDoc","saveSnapshot","debug","successfulSnapshots","s","setInterval","generateTelemetryReport","report","activeContexts","size","totalSnapshots","Array","from","values","arr","aggregateMetrics","emit","allContexts","ctx","totalPassed","totalFailed","averageAccuracy","averageConfidence","addPreTaskChecker","addPostTaskValidator","addIntegrationTestSuite","testSuite","addTruthValidator","addRollbackTrigger","getVerificationStatus","getMetrics","getStorageStats","getStats","isStorageReady","isReady","updateConfig","newConfig","maxAge","cutoff","entries","delete","DEFAULT_PRE_TASK_CHECKERS","description","requiredEnvVars","missing","score","join","available","recommendations","undefined","memUsage","memoryUsage","heapUsedMB","heapUsed","heapTotalMB","heapTotal","usageRatio","max","toFixed","DEFAULT_POST_TASK_VALIDATORS","hasErrors","hasFailedChecks","failedCheckCount","DEFAULT_TRUTH_VALIDATORS","dataStr","expectedStr","isEqual","truthful","discrepancies","evidence","match","DEFAULT_ROLLBACK_TRIGGERS","e","verificationHookManager"],"mappings":"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"}